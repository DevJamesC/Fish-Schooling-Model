function [updatedKrill] = move(krill)
% This function is used to update a fish's position 

global ENVIRONMENT PARAM MESSAGES

% struct containing weights for all directions
d=struct('up',0,'down',0,'left',0,'right',0,'upperLeft',0,...
    'upperRight',0,'lowerLeft',0,'lowerRight',0);
changes=[0,0,0,0,0,0,0,0];

% vectors basedon perception e.g. fish.perception = 3 is 
% [1,2,3]
perception = 1:1:(krill.perception);
perceptionReverse = sort(perception,'descend');
m=5;

% environment densities
dens = ENVIRONMENT.krill;
denh = ENVIRONMENT.herring;

%calculate weighting for upper left
 for i = perceptionReverse*-1
     for j = perceptionReverse*-1
         % check if this area is off the grid, if so then weight is
         % calculated off current position,
         % if not then go ahead and calculate weight of
         % the positions in that direction 
         if (((krill.position(1)+j>0) && krill.position(2)+i>0))   
             d.upperLeft = d.upperLeft + dens(krill.position(1) + j, krill.position(2) + i)./max(abs(i), abs(j));
             d.upperLeft = d.upperLeft - m*dens(krill.position(1) + j, krill.position(2) + i)./max(abs(i), abs(j));
             changes(1)=1;
         end
     end
 end
 
% calculate weighting for upper right
 for i = perceptionReverse
     for j = perceptionReverse*-1
         if ((krill.position(1)+j>0) && (krill.position(2)+i<=ENVIRONMENT.size))
             d.upperRight = d.upperRight + dens(krill.position(1) + j, krill.position(2) + i)./max(abs(i), abs(j));
             d.upperRight = d.upperRight - m*denh(krill.position(1) + j, krill.position(2) + i)./max(abs(i), abs(j));
             changes(2)=1;
         end
     end
 end
 
 %calculate weighting for lower left
 for i = perceptionReverse*-1
      for j = perceptionReverse
          if((krill.position(1)+j<=ENVIRONMENT.size) && (krill.position(2)+i>0))
             d.lowerLeft = d.lowerLeft + dens(krill.position(1) + j, krill.position(2) + i)./max(abs(i), abs(j));
             d.lowerLeft = d.lowerLeft - m*denh(krill.position(1) + j, krill.position(2) + i)./max(abs(i), abs(j));

             changes(3)=1;
          end
      end
 end

 % calculate weighting for lower right
 for i = perceptionReverse
      for j = perceptionReverse
          if((krill.position(1)+j<=ENVIRONMENT.size) && (krill.position(2)+i<=ENVIRONMENT.size))
             d.lowerRight = d.lowerRight + dens(krill.position(1) + j, krill.position(2) + i)./max(abs(i), abs(j));
             d.lowerRight = d.lowerRight - m*denh(krill.position(1) + j, krill.position(2) + i)./max(abs(i), abs(j));
             changes(4)=1;
          end
      end
 end

%calculates weighting for up, down, left, right 
 for i = perception
     if((krill.position(2)+i<=ENVIRONMENT.size))
         d.right = d.right + dens(krill.position(1), krill.position(2)+i)./abs(i);
         d.right = d.right - m*denh(krill.position(1), krill.position(2)+i)./abs(i);
         changes(5)=1;
     end
     if((krill.position(2)-i>0))
         d.left = d.left + dens(krill.position(1), krill.position(2)-i)./abs(i);
         d.left = d.left - m*(denh(krill.position(1), krill.position(2)-i)./abs(i));
         changes(6)=1;
     end
     if((krill.position(1)-i>0))
         d.up = d.up + dens(krill.position(1)-i, krill.position(2))./abs(i);   
         d.up = d.up - m*denh(krill.position(1)-i, krill.position(2))./abs(i); 
         changes(7)=1;
     end
     if((krill.position(1)+i<=ENVIRONMENT.size))
         d.down = d.down + dens(krill.position(1)+i, krill.position(2))./abs(i); 
         d.down = d.down - m*(denh(krill.position(1)+i, krill.position(2))./abs(i)); 
         changes(8)=1;
     end
 end 

% sort weights from highest to lowest 
Q = sort([d.up,d.down,d.left,d.right,d.upperLeft,d.lowerLeft,d.upperRight,d.lowerRight],'descend');
Q =Q(1:5);

% choose a weight based on % chances
i = rand;
switch true
    case ((0<=i)&&(i<0.75))
        weight = Q(1);
    case ((0.75<=i)&&(i<0.87))
        weight = Q(2);
    case ((0.87<=i)&&(i<0.93))
        weight = Q(3);
    case ((0.93<=i)&&(i<0.97))
        weight = Q(4);
    case ((0.97<=i)&&(i<=1.00))
        weight = Q(5);
end

row = krill.position(1);
col = krill.position(2);

% check if that weight was an edge case, if so then fish remains in current
% position, if not then densities are adjusted accordingly 
    function up
        if(changes(7)==1) && (dens(row-1,col)<PARAM.KRILL_DENSITY)  
           dens(row-1,col)=dens(row-1,col)+1;
           dens(row,col)= dens(row,col)-1;
           pos = [row-1,col];
        else
           pos = [row,col];
        end
    end
    function upperLeft
        if(changes(1)==1) && (dens(row-1,col-1)<PARAM.KRILL_DENSITY)
            dens(row-1,col-1)=dens(row-1,col-1)+1;
            dens(row,col)= dens(row,col)-1;
            pos = [row-1,col-1];
        else
            pos = [row,col];
        end
    end
        
        
switch true
    case(weight==0)
        strDi = ["up","down","left","right","upperLeft","upperRight","lowerLeft","lowerRight"];
        strDi = strDi(randperm(length(strDi)));
        di = strDi(1);         
    case(weight == d.up)
        up
    case (weight == d.upperLeft)
        upper
      
    case(weight == d.upperRight)
        if(changes(2)==1) && (dens(row-1,col+1)<PARAM.KRILL_DENSITY)
            dens(row-1,col+1)=dens(row-1,col+1)+1;
            dens(row,col)= dens(row,col)-1;

            pos = [row-1,col+1];
        else
            pos = [row,col];
        end
     case(weight == d.right)
         if(changes(5)==1) && (dens(row,col+1)<PARAM.KRILL_DENSITY)
            dens(row,col+1)=dens(row,col+1)+1;
            dens(row,col)= dens(row,col)-1;

            pos = [row,col+1];
         else
            pos = [row,col];
         end
     case(weight == d.left) 
         if(changes(6)==1) && (dens(row,col-1)<PARAM.KRILL_DENSITY)
            dens(row,col-1)=dens(row,col-1)+1;
            dens(row,col)= dens(row,col)-1;

            pos = [row,col-1];
         else
            pos = [row,col];
         end
     case(weight == d.down)
         if(changes(8)==1) && (dens(row+1,col)<PARAM.KRILL_DENSITY)           
            dens(row+1,col)=dens(row+1,col)+1;
            dens(row,col)= dens(row,col)-1;

            pos = [row+1,col];
         else
            pos = [row,col];

         end
     case(weight == d.lowerLeft)
         if(changes(3)==1)  && (dens(row+1,col-1)<PARAM.KRILL_DENSITY)
            dens(row+1,col-1)=dens(row+1,col-1)+1;
            dens(row,col)= dens(row,col)-1;

            pos = [row+1,col-1];
         else
            pos = [row,col];

         end
     case(weight == d.lowerRight)
         if(changes(4)==1) && (dens(row+1,col+1)<PARAM.KRILL_DENSITY)
            dens(row+1,col+1)=dens(row+1,col+1)+1;
            dens(row,col)= dens(row,col)-1;

            pos = [row+1,col+1];
         else
            pos = [row,col];
         end
end
% change environment 
ENVIRONMENT.krill = dens;
% new fish position 
krill.position = pos;
%return an updated fish
updatedKrill = krill();
end

